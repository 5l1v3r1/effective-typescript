<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Effective TypeScript</title>
  <icon>https://effectivetypescript.com/icon.png</icon>
  <subtitle>62 Specific Ways to Improve Your TypeScript</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://effectivetypescript.com/"/>
  <updated>2020-03-09T16:32:44.839Z</updated>
  <id>https://effectivetypescript.com/</id>
  
  <author>
    <name>Dan Vanderkam</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Item 41: Understand Evolving any</title>
    <link href="https://effectivetypescript.com/2020/03/09/evolving-any/"/>
    <id>https://effectivetypescript.com/2020/03/09/evolving-any/</id>
    <published>2020-03-09T16:34:56.000Z</published>
    <updated>2020-03-09T16:32:44.839Z</updated>
    
    <content type="html"><![CDATA[<p><em>This feature was introduced way back in <a href="https://github.com/Microsoft/TypeScript/wiki/What' target=" _blank" rel="noopener" s-new-in-typescript#improved-any-inference" target="_blank" onclick="trackOutboundLink('', 'https://github.com/Microsoft/TypeScript/wiki/What' target='); return false;">TypeScript 2.1</a> in 2016. The term &quot;evolving any&quot; is not widely used outside the TypeScript compiler itself, but I find it useful to have a name for this unusual pattern.</em></p><p>In TypeScript a variable&#39;s type is generally determined when it is declared. After this, it can be <em>refined</em> (by checking if it is <code>null</code>, for instance), but it cannot expand to include new values. There is one notable exception to this, however, involving <code>any</code> types.</p><p>In JavaScript, you might write a function to generate a range of numbers like this:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start, limit</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>When you convert this to TypeScript, it works exactly as you&#39;d expect:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;  <span class="hljs-comment">// Return type inferred as number[]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Upon closer inspection, however, it&#39;s surprising that this works! How does TypeScript know that the type of <code>out</code> is <code>number[]</code> when it&#39;s initialized as <code>[]</code>, which could be an array of any type?</p><p>Inspecting each of the three occurrences of <code>out</code> to reveal its inferred type starts to tell the story:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];  <span class="hljs-comment">// Type is any[]</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);  <span class="hljs-comment">// Type of out is any[]</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> out;  <span class="hljs-comment">// Type is number[]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The type of <code>out</code> starts as <code>any[]</code>, an undifferentiated array. But as we push <code>number</code> values onto it, its type &quot;evolves&quot; to become <code>number[]</code>.</p><p>This is distinct from narrowing (Item 22). An array&#39;s type can expand by pushing different elements onto it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> result = [];  <span class="hljs-comment">// Type is any[]</span><br>result.push(<span class="hljs-string">'a'</span>);<br>result  <span class="hljs-comment">// Type is string[]</span><br>result.push(<span class="hljs-number">1</span>);<br>result  <span class="hljs-comment">// Type is (string | number)[]</span><br></code></pre></td></tr></table></figure><p>With conditionals, the type can even vary across branches. Here we show the same behavior with a simple value, rather than an array:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> val;  <span class="hljs-comment">// Type is any</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span>) &#123;<br>  val = <span class="hljs-regexp">/hello/</span>;<br>  val  <span class="hljs-comment">// Type is RegExp</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  val = <span class="hljs-number">12</span>;<br>  val  <span class="hljs-comment">// Type is number</span><br>&#125;<br>val  <span class="hljs-comment">// Type is number | RegExp</span><br></code></pre></td></tr></table></figure><p>A final case that triggers this &quot;evolving any&quot; behavior is if a variable is initially <code>null</code>. This often comes up when you set a value in a <code>try</code>/<code>catch</code> block:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> val = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// Type is any</span><br><span class="hljs-keyword">try</span> &#123;<br>  somethingDangerous();<br>  val = <span class="hljs-number">12</span>;<br>  val  <span class="hljs-comment">// Type is number</span><br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'alas!'</span>);<br>&#125;<br>val  <span class="hljs-comment">// Type is number | null</span><br></code></pre></td></tr></table></figure><p>Interestingly, this behavior only happens when a variable&#39;s type is implicitly <code>any</code> with <code>noImplicitAny</code> set! Adding an <em>explicit</em> <code>any</code> keeps the type constant:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> val: <span class="hljs-built_in">any</span>;  <span class="hljs-comment">// Type is any</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span>) &#123;<br>  val = <span class="hljs-regexp">/hello/</span>;<br>  val  <span class="hljs-comment">// Type is any</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  val = <span class="hljs-number">12</span>;<br>  val  <span class="hljs-comment">// Type is any</span><br>&#125;<br>val  <span class="hljs-comment">// Type is any</span><br></code></pre></td></tr></table></figure><hr><!-- TODO: insert note icon --><p>This behavior can be confusing to follow in your editor since the type is only &quot;evolved&quot; <em>after</em> you assign or push an element. Inspecting the type on the line with the assignment will still show <code>any</code> or <code>any[]</code>.</p><hr><p>If you use a value before any assignment to it, you&#39;ll get an implicit any error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>  <span class="hljs-comment">//    ~~~ Variable 'out' implicitly has type 'any[]' in some</span><br>  <span class="hljs-comment">//        locations where its type cannot be determined</span><br>  <span class="hljs-keyword">if</span> (start === limit) &#123;<br>    <span class="hljs-keyword">return</span> out;<br>    <span class="hljs-comment">//     ~~~ Variable 'out' implicitly has an 'any[]' type</span><br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>Put another way, &quot;evolving&quot; <code>any</code> types are only <code>any</code> when you <em>write</em> to them. If you try to <em>read</em> from them while they&#39;re still <code>any</code>, you&#39;ll get an error.</p><p>Implicit <code>any</code> types do not evolve through function calls. The arrow function here trips up inference:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeSquares</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>     <span class="hljs-comment">// ~~~ Variable 'out' implicitly has type 'any[]' in some locations</span><br>  range(start, limit).forEach(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;<br>    out.push(i * i);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> out;<br>      <span class="hljs-comment">// ~~~ Variable 'out' implicitly has an 'any[]' type</span><br>&#125;<br></code></pre></td></tr></table></figure><p>In cases like this, you may want to consider using an array&#39;s <code>map</code> and <code>filter</code> methods to build arrays in a single statement and avoid iteration and evolving <code>any</code> entirely. See Items 23 and 27.</p><p>Evolving <code>any</code> comes with all the usual caveats about type inference. Is the correct type for your array really <code>(string|number)[]</code>? Or should it be <code>number[]</code> and you incorrectly pushed a <code>string</code>? You may still want to provide an explicit type annotation to get better error checking instead of using evolving <code>any</code>.</p><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><ul><li>While TypeScript types typically only <em>refine</em>, implicit <code>any</code> and <code>any[]</code> types are allowed to <em>evolve</em>. You should be able to recognize and understand this construct where it occurs.</li><li>For better error checking, consider providing an explicit type annotation instead of using evolving <code>any</code>.</li></ul>]]></content>
    
    <summary type="html">
    
      In TypeScript a variable&#39;s type is generally determined when it is declared. After this, it can be &lt;em&gt;refined&lt;/em&gt; (by checking if it is &lt;code&gt;null&lt;/code&gt;, for instance), but it cannot expand to include new values. There is one notable exception to this, however, involving &lt;code&gt;any&lt;/code&gt; types.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Welcome to Effective TypeScript!</title>
    <link href="https://effectivetypescript.com/2020/03/06/hello-world/"/>
    <id>https://effectivetypescript.com/2020/03/06/hello-world/</id>
    <published>2020-03-06T17:34:56.000Z</published>
    <updated>2020-03-12T15:40:49.361Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to the Effective TypeScript website! <a id="more"></a></p><p><a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://amzn.to/38s1oCK'); return false;"><em>Effective TypeScript</em></a> (the book) waspublished at the end of October 2019.</p><p>This companion site was a bit long in coming, but I hope to use it to:</p><ul><li>Post sample items</li><li>Post updates when TypeScript releases change the advice in the book.</li><li>Share links to conference presentations and videos.</li><li>Show examples of how to apply the items in the book.</li><li>Show general TypeScript tips &amp; tricks.</li></ul><p>An inspiration for this last one is the <a href="https://www.centauri-dreams.org/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.centauri-dreams.org/'); return false;">Centauri Dreams</a> blog, which started as acompanion site for a book published in 2004 but is still going strong 16 years later.</p><p>Look for posts every ~2 weeks.</p><p>I built this site using <a href="https://hexo.io/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://hexo.io/'); return false;">hexo</a>, a popular JavaScript-based static site generator. If you visit the <a href="https://effectivepython.com/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://effectivepython.com/'); return false;"><em>Effective Python</em> site</a>, you&#39;ll notice a strong family resemblance. So a big thanks to <a href="https://twitter.com/haxor" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://twitter.com/haxor'); return false;">Brett</a> for that!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to the Effective TypeScript website!
    
    </summary>
    
    
    
  </entry>
  
</feed>
