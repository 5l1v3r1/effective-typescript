<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Effective TypeScript</title>
  <icon>https://effectivetypescript.com/icon.png</icon>
  <subtitle>62 Specific Ways to Improve Your TypeScript</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://effectivetypescript.com/"/>
  <updated>2020-03-24T14:03:45.188Z</updated>
  <id>https://effectivetypescript.com/</id>
  
  <author>
    <name>Dan Vanderkam</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Item 31: Push Null Values to the Perimeter of Your Types</title>
    <link href="https://effectivetypescript.com/2020/03/24/null-values-to-perimeter/"/>
    <id>https://effectivetypescript.com/2020/03/24/null-values-to-perimeter/</id>
    <published>2020-03-24T14:05:00.000Z</published>
    <updated>2020-03-24T14:03:45.188Z</updated>
    
    <content type="html"><![CDATA[<p><em>Chapter 4 of <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://amzn.to/38s1oCK'); return false;">Effective TypeScript</a> covers type design: the process of crafting your types to accurately model your domain. Design your types well and you&#39;ll have a happy, productive relationship with the type checker. Design them poorly and you&#39;ll find yourself constantly fighting unproductive battles with it. This item discusses a frequent source of problems in type design: where to put your <code>null</code> types.</em></p><p>When you first turn on <code>strictNullChecks</code>, it may seem as though you have to add scores of <code>if</code> statements checking for <code>null</code> and <code>undefined</code> values throughout your code. This is often because the relationships between null and non-null values are implicit: when variable A is non-null, you know that variable B is also non-null and vice versa. These implicit relationships are confusing both for human readers of your code and for the type checker.</p><p>Values are easier to work with when they&#39;re either completely null or completely non-null, rather than a mix. You can model this by pushing the null values out to the perimeter of your structures.</p><p>Suppose you want to calculate the min and max of a list of numbers. We&#39;ll call this the &quot;extent.&quot; Here&#39;s an attempt:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extent</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> min, max;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num of nums) &#123;<br>    <span class="hljs-keyword">if</span> (!min) &#123;<br>      min = num;<br>      max = num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      min = <span class="hljs-built_in">Math</span>.min(min, num);<br>      max = <span class="hljs-built_in">Math</span>.max(max, num);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [min, max];<br>&#125;<br></code></pre></td></tr></table></figure><p>The code type checks (without <code>strictNullChecks</code>) and has an inferred return type of <code>number[]</code>, which seems fine. But it has a bug and a design flaw:</p><ul><li>If the min or max is zero, it may get overridden. For example, <code>extent([0, 1, 2])</code> will return <code>[1, 2]</code> rather than <code>[0, 2]</code>.</li><li>If the <code>nums</code> array is empty, the function will return <code>[undefined, undefined]</code>. This sort of object with several <code>undefined</code>s will be difficult for clients to work with and is exactly the sort of type that this item discourages. We know from reading the source code that <code>min</code> and <code>max</code> will either both be <code>undefined</code> or neither, but that information isn&#39;t represented in the type system.</li></ul><p>Turning on <code>strictNullChecks</code> makes both of these issues more apparent:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extent</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> min, max;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num of nums) &#123;<br>    <span class="hljs-keyword">if</span> (!min) &#123;<br>      min = num;<br>      max = num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      min = <span class="hljs-built_in">Math</span>.min(min, num);<br>      max = <span class="hljs-built_in">Math</span>.max(max, num);<br>                  <span class="hljs-comment">// ~~~ Argument of type 'number | undefined' is not</span><br>                  <span class="hljs-comment">//     assignable to parameter of type 'number'</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [min, max];<br>&#125;<br></code></pre></td></tr></table></figure><p>The return type of <code>extent</code> is now inferred as <code>(number | undefined)[]</code>, which makes the design flaw more apparent. This is likely to manifest as a type error wherever you call <code>extent</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [min, max] = extent([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-keyword">const</span> span = max - min;<br>          <span class="hljs-comment">// ~~~   ~~~ Object is possibly 'undefined'</span><br></code></pre></td></tr></table></figure><p>The error in the implementation of <code>extent</code> comes about because you&#39;ve excluded <code>undefined</code> as a value for <code>min</code> but not <code>max</code>. The two are initialized together, but this information isn&#39;t present in the type system. You could make it go away by adding a check for <code>max</code>, too, but this would be doubling down on the bug.</p><p>A better solution is to put the min and max in the same object and make this object either fully <code>null</code> or fully non-<code>null</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extent</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> result: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num of nums) &#123;<br>    <span class="hljs-keyword">if</span> (!result) &#123;<br>      result = [num, num];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result = [<span class="hljs-built_in">Math</span>.min(num, result[<span class="hljs-number">0</span>]), <span class="hljs-built_in">Math</span>.max(num, result[<span class="hljs-number">1</span>])];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>The return type is now <code>[number, number] | null</code>, which is easier for clients to work with. The min and max can be retrieved with either a non-null assertion:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [min, max] = extent([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])!;<br><span class="hljs-keyword">const</span> span = max - min;  <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>or a single check:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> range = extent([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-keyword">if</span> (range) &#123;<br>  <span class="hljs-keyword">const</span> [min, max] = range;<br>  <span class="hljs-keyword">const</span> span = max - min;  <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure><p>By using a single object to track the extent, we&#39;ve improved our design, helped TypeScript understand the relationship between null values, and fixed the bug: the <code>if (!result)</code> check is now problem free.</p><p>A mix of null and non-null values can also lead to problems in classes. For instance, suppose you have a class that represents both a user and their posts on a forum:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> UserPosts &#123;<br>  user: UserInfo | <span class="hljs-literal">null</span>;<br>  posts: Post[] | <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">this</span>.user = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">this</span>.posts = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">async</span> init(userId: <span class="hljs-built_in">string</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all([<br>      <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">this</span>.user = <span class="hljs-keyword">await</span> fetchUser(userId),<br>      <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">this</span>.posts = <span class="hljs-keyword">await</span> fetchPostsForUser(userId)<br>    ]);<br>  &#125;<br><br>  getUserName() &#123;<br>    <span class="hljs-comment">// ...?</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>While the two network requests are loading, the <code>user</code> and <code>posts</code> properties will be <code>null</code>. At any time, they might both be <code>null</code>, one might be <code>null</code>, or they might both be non-<code>null</code>. There are four possibilities. This complexity will seep into every method on the class. This design is almost certain to lead to confusion, a proliferation of <code>null</code> checks, and bugs.</p><p>A better design would wait until all the data used by the class is available:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> UserPosts &#123;<br>  user: UserInfo;<br>  posts: Post[];<br><br>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">user: UserInfo, posts: Post[]</span>) &#123;<br>    <span class="hljs-keyword">this</span>.user = user;<br>    <span class="hljs-keyword">this</span>.posts = posts;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> init(userId: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span>&lt;UserPosts&gt; &#123;<br>    <span class="hljs-keyword">const</span> [user, posts] = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([<br>      fetchUser(userId),<br>      fetchPostsForUser(userId)<br>    ]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserPosts(user, posts);<br>  &#125;<br><br>  getUserName() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.user.name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Now the <code>UserPosts</code> class is fully non-<code>null</code>, and it&#39;s easy to write correct methods on it. Of course, if you need to perform operations while data is partially loaded, then you&#39;ll need to deal with the multiplicity of <code>null</code> and non-<code>null</code> states.</p><p>(Don&#39;t be tempted to replace nullable properties with Promises. This tends to lead to even more confusing code and forces all your methods to be async. Promises clarify the code that loads data but tend to have the opposite effect on the class that uses that data.)</p><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><ul><li>Avoid designs in which one value being <code>null</code> or not <code>null</code> is implicitly related to another value being <code>null</code> or not <code>null</code>.</li><li>Push <code>null</code> values to the perimeter of your API by making larger objects either <code>null</code> or fully non-<code>null</code>. This will make code clearer both for human readers and for the type checker.</li><li>Consider creating a fully non-<code>null</code> class and constructing it when all values are available.</li><li>While <code>strictNullChecks</code> may flag many issues in your code, it&#39;s indispensable for surfacing the behavior of functions with respect to null values.</li></ul>]]></content>
    
    <summary type="html">
    
      When you first turn on &lt;code&gt;strictNullChecks&lt;/code&gt;, it may seem as though you have to add scores of &lt;code&gt;if&lt;/code&gt; statements checking for &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values throughout your code. This is often because the relationships between null and non-null values are implicit: when variable A is non-null, you know that variable B is also non-null and vice versa. These implicit relationships are confusing both for human readers of your code and for the type checker.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Item 41: Understand Evolving any</title>
    <link href="https://effectivetypescript.com/2020/03/09/evolving-any/"/>
    <id>https://effectivetypescript.com/2020/03/09/evolving-any/</id>
    <published>2020-03-09T16:34:56.000Z</published>
    <updated>2020-03-09T16:32:44.839Z</updated>
    
    <content type="html"><![CDATA[<p><em>This feature was introduced way back in <a href="https://github.com/Microsoft/TypeScript/wiki/What' target=" _blank" rel="noopener" s-new-in-typescript#improved-any-inference" target="_blank" onclick="trackOutboundLink('', 'https://github.com/Microsoft/TypeScript/wiki/What' target='); return false;">TypeScript 2.1</a> in 2016. The term &quot;evolving any&quot; is not widely used outside the TypeScript compiler itself, but I find it useful to have a name for this unusual pattern.</em></p><p>In TypeScript a variable&#39;s type is generally determined when it is declared. After this, it can be <em>refined</em> (by checking if it is <code>null</code>, for instance), but it cannot expand to include new values. There is one notable exception to this, however, involving <code>any</code> types.</p><p>In JavaScript, you might write a function to generate a range of numbers like this:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start, limit</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>When you convert this to TypeScript, it works exactly as you&#39;d expect:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;  <span class="hljs-comment">// Return type inferred as number[]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Upon closer inspection, however, it&#39;s surprising that this works! How does TypeScript know that the type of <code>out</code> is <code>number[]</code> when it&#39;s initialized as <code>[]</code>, which could be an array of any type?</p><p>Inspecting each of the three occurrences of <code>out</code> to reveal its inferred type starts to tell the story:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];  <span class="hljs-comment">// Type is any[]</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);  <span class="hljs-comment">// Type of out is any[]</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> out;  <span class="hljs-comment">// Type is number[]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The type of <code>out</code> starts as <code>any[]</code>, an undifferentiated array. But as we push <code>number</code> values onto it, its type &quot;evolves&quot; to become <code>number[]</code>.</p><p>This is distinct from narrowing (Item 22). An array&#39;s type can expand by pushing different elements onto it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> result = [];  <span class="hljs-comment">// Type is any[]</span><br>result.push(<span class="hljs-string">'a'</span>);<br>result  <span class="hljs-comment">// Type is string[]</span><br>result.push(<span class="hljs-number">1</span>);<br>result  <span class="hljs-comment">// Type is (string | number)[]</span><br></code></pre></td></tr></table></figure><p>With conditionals, the type can even vary across branches. Here we show the same behavior with a simple value, rather than an array:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> val;  <span class="hljs-comment">// Type is any</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span>) &#123;<br>  val = <span class="hljs-regexp">/hello/</span>;<br>  val  <span class="hljs-comment">// Type is RegExp</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  val = <span class="hljs-number">12</span>;<br>  val  <span class="hljs-comment">// Type is number</span><br>&#125;<br>val  <span class="hljs-comment">// Type is number | RegExp</span><br></code></pre></td></tr></table></figure><p>A final case that triggers this &quot;evolving any&quot; behavior is if a variable is initially <code>null</code>. This often comes up when you set a value in a <code>try</code>/<code>catch</code> block:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> val = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// Type is any</span><br><span class="hljs-keyword">try</span> &#123;<br>  somethingDangerous();<br>  val = <span class="hljs-number">12</span>;<br>  val  <span class="hljs-comment">// Type is number</span><br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'alas!'</span>);<br>&#125;<br>val  <span class="hljs-comment">// Type is number | null</span><br></code></pre></td></tr></table></figure><p>Interestingly, this behavior only happens when a variable&#39;s type is implicitly <code>any</code> with <code>noImplicitAny</code> set! Adding an <em>explicit</em> <code>any</code> keeps the type constant:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> val: <span class="hljs-built_in">any</span>;  <span class="hljs-comment">// Type is any</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span>) &#123;<br>  val = <span class="hljs-regexp">/hello/</span>;<br>  val  <span class="hljs-comment">// Type is any</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  val = <span class="hljs-number">12</span>;<br>  val  <span class="hljs-comment">// Type is any</span><br>&#125;<br>val  <span class="hljs-comment">// Type is any</span><br></code></pre></td></tr></table></figure><hr><!-- TODO: insert note icon --><p>This behavior can be confusing to follow in your editor since the type is only &quot;evolved&quot; <em>after</em> you assign or push an element. Inspecting the type on the line with the assignment will still show <code>any</code> or <code>any[]</code>.</p><hr><p>If you use a value before any assignment to it, you&#39;ll get an implicit any error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>  <span class="hljs-comment">//    ~~~ Variable 'out' implicitly has type 'any[]' in some</span><br>  <span class="hljs-comment">//        locations where its type cannot be determined</span><br>  <span class="hljs-keyword">if</span> (start === limit) &#123;<br>    <span class="hljs-keyword">return</span> out;<br>    <span class="hljs-comment">//     ~~~ Variable 'out' implicitly has an 'any[]' type</span><br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; limit; i++) &#123;<br>    out.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>Put another way, &quot;evolving&quot; <code>any</code> types are only <code>any</code> when you <em>write</em> to them. If you try to <em>read</em> from them while they&#39;re still <code>any</code>, you&#39;ll get an error.</p><p>Implicit <code>any</code> types do not evolve through function calls. The arrow function here trips up inference:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeSquares</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, limit: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out = [];<br>     <span class="hljs-comment">// ~~~ Variable 'out' implicitly has type 'any[]' in some locations</span><br>  range(start, limit).forEach(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;<br>    out.push(i * i);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> out;<br>      <span class="hljs-comment">// ~~~ Variable 'out' implicitly has an 'any[]' type</span><br>&#125;<br></code></pre></td></tr></table></figure><p>In cases like this, you may want to consider using an array&#39;s <code>map</code> and <code>filter</code> methods to build arrays in a single statement and avoid iteration and evolving <code>any</code> entirely. See Items 23 and 27.</p><p>Evolving <code>any</code> comes with all the usual caveats about type inference. Is the correct type for your array really <code>(string|number)[]</code>? Or should it be <code>number[]</code> and you incorrectly pushed a <code>string</code>? You may still want to provide an explicit type annotation to get better error checking instead of using evolving <code>any</code>.</p><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><ul><li>While TypeScript types typically only <em>refine</em>, implicit <code>any</code> and <code>any[]</code> types are allowed to <em>evolve</em>. You should be able to recognize and understand this construct where it occurs.</li><li>For better error checking, consider providing an explicit type annotation instead of using evolving <code>any</code>.</li></ul>]]></content>
    
    <summary type="html">
    
      In TypeScript a variable&#39;s type is generally determined when it is declared. After this, it can be &lt;em&gt;refined&lt;/em&gt; (by checking if it is &lt;code&gt;null&lt;/code&gt;, for instance), but it cannot expand to include new values. There is one notable exception to this, however, involving &lt;code&gt;any&lt;/code&gt; types.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Welcome to Effective TypeScript!</title>
    <link href="https://effectivetypescript.com/2020/03/06/hello-world/"/>
    <id>https://effectivetypescript.com/2020/03/06/hello-world/</id>
    <published>2020-03-06T17:34:56.000Z</published>
    <updated>2020-03-12T15:40:49.361Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to the Effective TypeScript website! <a id="more"></a></p><p><a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://amzn.to/38s1oCK'); return false;"><em>Effective TypeScript</em></a> (the book) waspublished at the end of October 2019.</p><p>This companion site was a bit long in coming, but I hope to use it to:</p><ul><li>Post sample items</li><li>Post updates when TypeScript releases change the advice in the book.</li><li>Share links to conference presentations and videos.</li><li>Show examples of how to apply the items in the book.</li><li>Show general TypeScript tips &amp; tricks.</li></ul><p>An inspiration for this last one is the <a href="https://www.centauri-dreams.org/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://www.centauri-dreams.org/'); return false;">Centauri Dreams</a> blog, which started as acompanion site for a book published in 2004 but is still going strong 16 years later.</p><p>Look for posts every ~2 weeks.</p><p>I built this site using <a href="https://hexo.io/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://hexo.io/'); return false;">hexo</a>, a popular JavaScript-based static site generator. If you visit the <a href="https://effectivepython.com/" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://effectivepython.com/'); return false;"><em>Effective Python</em> site</a>, you&#39;ll notice a strong family resemblance. So a big thanks to <a href="https://twitter.com/haxor" target="_blank" rel="noopener" onclick="trackOutboundLink('', 'https://twitter.com/haxor'); return false;">Brett</a> for that!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to the Effective TypeScript website!
    
    </summary>
    
    
    
  </entry>
  
</feed>
